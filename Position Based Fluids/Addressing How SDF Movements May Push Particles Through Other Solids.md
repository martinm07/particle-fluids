As things currently stand, the example below would lead to the problematic behaviour also shown, as the the movement algorithm only considers triangles, ignoring the line segments they had been split up into (because it would be far too complicated otherwise).
![[sdf-wrong-behaviour.png]]
To address this:
1. We can do a ray march from the initial position of a particle to where the movement area takes it, and if it runs into a solid before then, we can stop it there. This of course requires information on what's "behind" the movement area, and so we'd need to provide two textures to GPUC5; the one containing the movement areas, and the reconstruction of the SDF that would be provided next frame. The problem here is that the particle would be stopped in the middle of the movement area, without getting moved *properly*.
2. Thus in addition to that, we should consider the line segments of the frontier only, and consider percentages of the frontier through the line segments, skipping the gaps where it's empty (because it intersects with other solids). The movement area, being defined as the convex hull of vertices, should also only consider the line segments of the frontier. And if the segments of the frontier end up being nothing (because it is entirely contained in other solids), then we can refer back to the original side of a triangle. This is because the particles will be stopped before, by the ray march, anyways. And speaking of, the ray march may still leave particles inside of the movement area (naturally, any time it *is* useful this will be the result), but we can now be reasonably confident that the particle had nowhere better to go. Nonetheless, it should still be good to do
3. Take advantage of multiple solver iterations by having only the first iteration include the movements; the subsequent ones having the static, updated SDF only. This is as simple as setting x ‚Üê x* for the next GPUC5 call, and what it does is really just let the extra iterations not go to waste. As it currently stands, when a particle is caught inside a movement area, each iteration it will calculate newXStar in GPUC5, before checking if x is inside a solid and realizing that the SDF adjustment takes precedent. This only needs to happen once! And doing so also means that the ray march described above wouldn't visually be leaving particles (potentially) inside the new position of the triangle of the movement area for a frame.